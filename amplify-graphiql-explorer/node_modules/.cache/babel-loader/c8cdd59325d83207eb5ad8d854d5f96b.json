{"ast":null,"code":"import{decode,sign,verify}from'jsonwebtoken';export function generateToken(decodedToken){try{if(typeof decodedToken==='string'){decodedToken=JSON.parse(decodedToken);}var token=sign(decodedToken,'open-secrete');verify(token,'open-secrete');return token;}catch(e){var err=new Error('Error when generating OIDC token: '+e.message);throw err;}}export function parse(token){var decodedToken=decode(token);return decodedToken;}/**\n * Updates the exp time of the static token to ensure the shipped token is fresh. If user passes an\n * issuer, updates the token with the issuer\n * @param token\n * @param issuer\n */export function refreshToken(token,issuer){var tokenObj=parse(token);if(!Object.keys(tokenObj).length){throw new Error(\"Invalid token \".concat(token));}if(issuer){tokenObj.iss=issuer;}tokenObj.exp=Math.floor(Date.now()/100+20000);return generateToken(JSON.stringify(tokenObj));}","map":{"version":3,"sources":["/home/katesclau/returnmates/amplify-appsync-simulator/amplify-graphiql-explorer/src/utils/jwt.ts"],"names":["decode","sign","verify","generateToken","decodedToken","JSON","parse","token","e","err","Error","message","refreshToken","issuer","tokenObj","Object","keys","length","iss","exp","Math","floor","Date","now","stringify"],"mappings":"AAAA,OAASA,MAAT,CAAiBC,IAAjB,CAAuBC,MAAvB,KAAqC,cAArC,CAEA,MAAO,SAASC,CAAAA,aAAT,CAAuBC,YAAvB,CAA8D,CACnE,GAAI,CACF,GAAI,MAAOA,CAAAA,YAAP,GAAwB,QAA5B,CAAsC,CACpCA,YAAY,CAAGC,IAAI,CAACC,KAAL,CAAWF,YAAX,CAAf,CACD,CACD,GAAMG,CAAAA,KAAK,CAAGN,IAAI,CAACG,YAAD,CAAe,cAAf,CAAlB,CACAF,MAAM,CAACK,KAAD,CAAQ,cAAR,CAAN,CACA,MAAOA,CAAAA,KAAP,CACD,CAAC,MAAOC,CAAP,CAAU,CACV,GAAMC,CAAAA,GAAG,CAAG,GAAIC,CAAAA,KAAJ,CAAU,qCAAuCF,CAAC,CAACG,OAAnD,CAAZ,CACA,KAAMF,CAAAA,GAAN,CACD,CACF,CAED,MAAO,SAASH,CAAAA,KAAT,CAAeC,KAAf,CAA8B,CACnC,GAAMH,CAAAA,YAAY,CAAGJ,MAAM,CAACO,KAAD,CAA3B,CACA,MAAOH,CAAAA,YAAP,CACD,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASQ,CAAAA,YAAT,CAAsBL,KAAtB,CAAqCM,MAArC,CAA8D,CACnE,GAAMC,CAAAA,QAAa,CAAGR,KAAK,CAACC,KAAD,CAA3B,CACA,GAAI,CAACQ,MAAM,CAACC,IAAP,CAAYF,QAAZ,EAAsBG,MAA3B,CAAmC,CACjC,KAAM,IAAIP,CAAAA,KAAJ,yBAA2BH,KAA3B,EAAN,CACD,CACD,GAAIM,MAAJ,CAAY,CACVC,QAAQ,CAACI,GAAT,CAAeL,MAAf,CACD,CACDC,QAAQ,CAACK,GAAT,CAAeC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,GAAa,GAAb,CAAmB,KAA9B,CAAf,CACA,MAAOpB,CAAAA,aAAa,CAACE,IAAI,CAACmB,SAAL,CAAeV,QAAf,CAAD,CAApB,CACD","sourcesContent":["import { decode, sign, verify } from 'jsonwebtoken';\n\nexport function generateToken(decodedToken: string | object): string {\n  try {\n    if (typeof decodedToken === 'string') {\n      decodedToken = JSON.parse(decodedToken);\n    }\n    const token = sign(decodedToken, 'open-secrete');\n    verify(token, 'open-secrete');\n    return token;\n  } catch (e) {\n    const err = new Error('Error when generating OIDC token: ' + e.message);\n    throw err;\n  }\n}\n\nexport function parse(token): object {\n  const decodedToken = decode(token);\n  return decodedToken;\n}\n\n/**\n * Updates the exp time of the static token to ensure the shipped token is fresh. If user passes an\n * issuer, updates the token with the issuer\n * @param token\n * @param issuer\n */\nexport function refreshToken(token: string, issuer?: string): string {\n  const tokenObj: any = parse(token);\n  if (!Object.keys(tokenObj).length) {\n    throw new Error(`Invalid token ${token}`);\n  }\n  if (issuer) {\n    tokenObj.iss = issuer;\n  }\n  tokenObj.exp = Math.floor(Date.now() / 100 + 20000);\n  return generateToken(JSON.stringify(tokenObj));\n}\n"]},"metadata":{},"sourceType":"module"}